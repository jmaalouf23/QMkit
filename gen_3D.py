import os
from os import path
import sys
import numpy as np
import subprocess
import time
import rdkit
from rdkit import Chem
from rdkit.Chem import AllChem

from dft_utils import ConfToMol,no_to_symbol

"""
Author: Joseph Maalouf

Set of functions to 


• generate 3D coordinates from smiles strings and write text files with those coordinates
• manipulating 3D coordinates in the form of textfiles, lists, arrays, or rdkit mols/conformers
• extract 3D coordinates from the output files of QM or DFT calculations

"""

def get_xyz_from_smiles_string(smiles: str ,filename: str,numConfs: int =1,conf_id=False,randomseed=0xf00d,return_mol=False,write_file=True):
    
    """
    Uses RDkit to create an xyz textfile with 3D molecular coordinates from a smiles string. The output format of the xyz file is the same as what is made by open babel. The textfile is a .xyz format containing MMFF optimized conformers.
    Params
    
    smiles      : smiles string
    filename    : path, including name of file (without xyz extension), of the xyz file to be written.
    numConfs    : number of conformers to be generated by RDkit. Default is 1 but it is recommended to generate more and pick the lowest energy converged conformer.        
    conf_id     : of the generated conformers, conf_id species the geometry of which conformer to use to generate the xyz file. 
                  If not specified the conformer id of the lowest energy conformer is used.
    randomseed  : A random seed is used to generate conformers. For reproducability we set it to a default value.
    write_file  : If True,  a text file containing in the .xyz format containing MMFF optimized conformers with its name specified by the filename is written. 
    
    Returns
    if return_mol is True: returns the mol object of the lowest energy conformer
    """
    
    mol=Chem.MolFromSmiles(smiles)
    mol=Chem.AddHs(mol)
    
    try:
        cids = AllChem.EmbedMultipleConfs(mol, numConfs=1,randomSeed=randomseed)
        res = AllChem.MMFFOptimizeMoleculeConfs(mol,numThreads=0)
    except:
        #If molecule cannot be emmbedded remove chiral stereochemistry and try again in case this was the issue.
        if '@' in smiles:
            smiles=smiles.replace('@','')
            print(f'CHIRAL STEROCHEMISTRY REMOVED, SMILES={smiles}')
            mol=Chem.MolFromSmiles(smiles)
            mol=Chem.AddHs(mol)
            cids = AllChem.EmbedMultipleConfs(mol, numConfs=numConfs,randomSeed=randomseed)
            res = AllChem.MMFFOptimizeMoleculeConfs(mol,numThreads=0)
            
        else:
            print('EMBEDDING FAILED FOR UNKNOWN REASON')
     
    cids = AllChem.EmbedMultipleConfs(mol, numConfs=numConfs,randomSeed=randomseed)
    res = AllChem.MMFFOptimizeMoleculeConfs(mol,numThreads=0)
    
    if conf_id ==False: #If False the lowest energy converged conformer ID is used, otherwise the specified conf_id will be used
        
        res_converged=[v for i,v in enumerate(res) if res[i][0]==0]
        
        if len(res_converged) > 0:
            conf_id=res.index(min(res_converged, key = lambda t: t[1]))
        else:
            # If there are no converged conformers, try again but with useRandomCoords=True and using maxAttempts=400 instead of the default 200.
            # This will just increase the liklihood of getting a conveged conformer. This case will likely not have to be used.
            cids=AllChem.EmbedMultipleConfs(mol,numConfs=100,randomSeed=0xf00d,maxAttempts=400,useRandomCoords=True)
            res = AllChem.MMFFOptimizeMoleculeConfs(mol,numThreads=0)
            res_converged=[v for i,v in enumerate(res) if res[i][0]==0]
            if len(res_converged) > 0:
                conf_id=res.index(min(res_converged, key = lambda t: t[1]))
            else:
                conf_id=res.index(min(res, key = lambda t: t[1]))
    xyz=get_xyz_from_mol(mol,conf_id=conf_id) #gets an array of xyz values
    
    if write_file:
        write_xyz_from_xyz_arr(xyz,filename) #Writes xyz text file
        
    if return_mol:
        return ConfToMol(mol, conf_id)
        
    

def get_xyz_from_mol(mol,conf_id: int =0,randomseed=0xf00d)-> np.ndarray:
    
    """
    Extracts a numpy array of symbols and coordinates from an rdkit molecule conformer.
    Returns a `(N, 4)` numpy array of 3d coords of given rdkit molecule.
    N is the number of atoms in the molecule.
    Dim 0 : atomic symbol
    Dim 1 : x coordinates
    Dim 2 : y coordinates
    Dim 3 : z coordinates
    
    Params
    mol     : rdkit molecule to extract coordinates for
    conf_id : the conformer id number from which to extract 3D coordinates
    
    Returns
    -------
    Numpy ndarray of shape `(N, 4)` where `N = mol.GetNumAtoms()`.
    """

    xyz = np.zeros((mol.GetNumAtoms(), 4),dtype=object)
    
    if conf_id is not None:
        conf = mol.GetConformer(id=conf_id)
    else:
        conf = mol.GetConformer()
    atoms=mol.GetAtoms()
    for i in range(conf.GetNumAtoms()):
        position = conf.GetAtomPosition(i)
        atom=mol.GetAtomWithIdx(i)
        xyz[i,0] = atom.GetSymbol()
        xyz[i, 1] = position.x
        xyz[i, 2] = position.y
        xyz[i, 3] = position.z
    return (xyz)


def get_xyz_from_xyz_arr(xyz: np.ndarray,filename: str ,include_total_atoms: bool =False) -> None:
    
    """Writes an XYZ text file from and xyz array of the same formate given by
    get_xyz_from_mol. The ouput format exactly matches the format given by open babel.
    
    ----------
    Params
    
    xyz: numpy array of shape (N , 4) where `N = mol.GetNumAtoms(). The first
        column should be the atom label and the next 3 are the x,y,z coordinates
        
    filename: path to .xyz text file where information will be saved
    
    Returns
    -------
    .xyz text file containing atom lables and x,y,z coordinates.
    """    
    #might have to make filename just the full path
    writepath = os.path.join(os.getcwd(),f'{filename}.xyz')
    mode = 'a' if os.path.exists(writepath) else 'w'
    with open(writepath, mode) as f:
        f.truncate(0)
        
        n,m=np.shape(xyz)
        if include_total_atoms:
            f.write(f'{n}\n')
        else:
            f.write('\n')
        f.write('\n')
        for i in range(n):
            f.write(f'{xyz[i,0]}{xyz[i,1]:>17,.6f}{xyz[i,2]:>15,.6f}{xyz[i,3]:>15,.6f}\n')
        f.close()
        
    
    
def combine_labels_and_xyz(labels : list, xyz : list) -> np.ndarray:
    
    """Combines a list of atom labels and list of lists of 3D coordinates
    into a single N x D+1 np array which can be used in the function
    write_xyz_from_xyz_arr()
    ----------
    labels: List of atom labels,  of size (N,). Each label should
    be a string
    
    xyz: List of lists of atom coordinates, each inner list contains the 3
    coordinates of atom i. ie [[0,0,0,],[1,1,1]] for 2 atoms with coordinates (0,0,0)
    and (1,1,1)
    
    Returns
    -------
    Returns a combined numpy array of size N x D+1 where the first column are the labels
    and the remaining columns are the cooridnates, much like a .xyz file
    """ 
    
    
    
    arr1,arr2= np.expand_dims(labels,1),np.array(xyz) #This unflattens the labels array 
    
    n,d=np.shape(np.array(arr2))
    arr=np.empty((n,d+1),dtype='object')
    arr[:,[0]]=arr1
    arr[:,1:]=arr2
    
    return arr  


def get_xyz_from_output(file):

    
    """
    Makes an XYZ file from the final geometry of a gaussian calulcation obtained from the output file.
    
    Arguments:
    Gaussian output text file from a geom and freq calculation
    
    """
    
    temp_data=cclib.io.ccread(file)
    xyz=temp_data.atomcoords[-1,:,:]
    atnos=temp_data.atomnos
    atsymbs=[no_to_symbol(x) for x in atnos]
    n,m=np.shape(xyz)
    
    filename=os.path.basename(os.path.normpath(file))
    split_file=filename.split('.')
    base_file=split_file[0]
    
    writepath = os.path.join(os.getcwd(),f'{base_file}_converged.xyz')
    mode = 'a' if os.path.exists(writepath) else 'w'

    with open(writepath, mode) as f:
        f.truncate(0)
        f.write(f'{len(atsymbs)}')
        f.write('\n\n')
        for i in range(n):
            f.write(f'{atsymbs[i]}{xyz[i,0]:>17,.6f}{xyz[i,1]:>15,.6f}{xyz[i,2]:>15,.6f}\n')
        f.close()

def GetCoordsFromMolBlock(mb):
    
    
    header_lines=4
    
    lines=mb.splitlines()
    n=int(lines[3].split()[0])
    end_line=header_lines+n
    
    xyz=np.zeros((n,4),dtype='object')
    for i,line in enumerate(lines[header_lines:end_line]):
        split_line=line.split()

        xyz[i,0]=split_line[3]
        xyz[i,1]=float(split_line[0])
        xyz[i,2]=float(split_line[1])
        xyz[i,3]=float(split_line[2])
        
    return xyz
        
        
def make_smi_file(smiles: str , save_path: str) -> None: 
    
    """
    Given a smile, makes a file containing the smiles with extension .smi
    
    Params
    smiles    : smiles string to be written in file
    save_path : directory where file will be written. Do not include file extension
    
    """
    
    writepath = os.path.join(os.getcwd(),f'{save_path}.smi')
    mode = 'a' if os.path.exists(writepath) else 'w'
    
    with open(writepath, mode) as f:
        f.truncate(0)
        f.write(smiles)
        